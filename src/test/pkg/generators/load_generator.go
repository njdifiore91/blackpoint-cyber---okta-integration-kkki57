// Package generators provides test data generation capabilities for the BlackPoint Security Integration Framework
package generators

import (
    "context"
    "fmt"
    "sync"
    "sync/atomic"
    "time"

    "github.com/prometheus/client_golang/prometheus" // v1.12.0
)

// Default configuration values
const (
    DefaultLoadDuration        = 5 * time.Minute
    DefaultConcurrency        = 10
    MaxConcurrency           = 200
    DefaultRampUpPeriod      = 30 * time.Second
    SecurityValidationInterval = time.Minute
    ComplianceCheckInterval   = 5 * time.Minute
)

// Metrics collectors
var (
    loadMetrics = struct {
        eventsGenerated   *prometheus.CounterVec
        eventLatency     *prometheus.HistogramVec
        securityErrors   *prometheus.CounterVec
        complianceErrors *prometheus.CounterVec
    }{
        eventsGenerated: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "blackpoint_load_events_generated_total",
                Help: "Total number of events generated by tier",
            },
            []string{"tier"},
        ),
        eventLatency: prometheus.NewHistogramVec(
            prometheus.HistogramOpts{
                Name: "blackpoint_load_event_latency_seconds",
                Help: "Event processing latency by tier",
                Buckets: []float64{0.1, 0.5, 1, 2, 5, 10, 30},
            },
            []string{"tier"},
        ),
        securityErrors: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "blackpoint_load_security_errors_total",
                Help: "Number of security validation errors",
            },
            []string{"type"},
        ),
        complianceErrors: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "blackpoint_load_compliance_errors_total",
                Help: "Number of compliance validation errors",
            },
            []string{"standard"},
        ),
    }
)

// LoadGeneratorConfig defines configuration for the load generator
type LoadGeneratorConfig struct {
    Duration           time.Duration
    Concurrency       int
    RampUpPeriod      time.Duration
    EventTypes        []string
    SecurityContext   map[string]interface{}
    ComplianceRules   map[string][]string
    ValidationRules   []ValidationRule
    PerformanceParams PerformanceParams
}

// LoadGenerator implements a high-performance load generator with security validation
type LoadGenerator struct {
    config           *LoadGeneratorConfig
    eventGenerator   *EventGenerator
    clientWaitGroup  sync.WaitGroup
    stopChan         chan struct{}
    metrics          *LoadMetrics
    securityCtx      *SecurityContext
    complianceConfig *ComplianceConfig
    mutex            sync.RWMutex
    activeClients    int32
}

// LoadMetrics tracks load generation statistics
type LoadMetrics struct {
    EventsGenerated    map[string]uint64
    ValidationErrors   uint64
    ComplianceErrors   uint64
    ProcessingLatency  map[string]time.Duration
    SecurityViolations uint64
    ActiveClients      int32
}

// NewLoadGenerator creates a new load generator instance with security validation
func NewLoadGenerator(config *LoadGeneratorConfig, securityCtx *SecurityContext) (*LoadGenerator, error) {
    if config == nil {
        return nil, fmt.Errorf("load generator config is required")
    }

    // Apply default configuration
    if config.Duration == 0 {
        config.Duration = DefaultLoadDuration
    }
    if config.Concurrency == 0 {
        config.Concurrency = DefaultConcurrency
    }
    if config.Concurrency > MaxConcurrency {
        return nil, fmt.Errorf("concurrency exceeds maximum allowed (%d)", MaxConcurrency)
    }
    if config.RampUpPeriod == 0 {
        config.RampUpPeriod = DefaultRampUpPeriod
    }

    // Initialize event generator with security context
    eventGen, err := NewEventGenerator(&GeneratorConfig{
        BatchSize:         1000,
        ErrorRate:         0.1,
        ComplianceEnabled: true,
        SecurityContext:   securityCtx.ToMap(),
        ValidationRules:   config.ValidationRules,
        PerformanceParams: config.PerformanceParams,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to initialize event generator: %v", err)
    }

    return &LoadGenerator{
        config:         config,
        eventGenerator: eventGen,
        stopChan:      make(chan struct{}),
        metrics: &LoadMetrics{
            EventsGenerated:   make(map[string]uint64),
            ProcessingLatency: make(map[string]time.Duration),
        },
        securityCtx:      securityCtx,
        complianceConfig: NewComplianceConfig(config.ComplianceRules),
    }, nil
}

// Start begins load generation with security monitoring
func (lg *LoadGenerator) Start(ctx context.Context) error {
    lg.mutex.Lock()
    defer lg.mutex.Unlock()

    // Start security validation goroutine
    go lg.monitorSecurity(ctx)

    // Start compliance monitoring goroutine
    go lg.monitorCompliance(ctx)

    // Calculate client ramp-up interval
    rampUpInterval := lg.config.RampUpPeriod / time.Duration(lg.config.Concurrency)

    // Start client goroutines with gradual ramp-up
    for i := 0; i < lg.config.Concurrency; i++ {
        lg.clientWaitGroup.Add(1)
        go lg.runClient(ctx)
        atomic.AddInt32(&lg.activeClients, 1)
        time.Sleep(rampUpInterval)
    }

    return nil
}

// Stop gracefully stops load generation
func (lg *LoadGenerator) Stop() {
    close(lg.stopChan)
    lg.clientWaitGroup.Wait()
}

// GetMetrics returns current load generation metrics
func (lg *LoadGenerator) GetMetrics() *LoadMetrics {
    lg.mutex.RLock()
    defer lg.mutex.RUnlock()

    metrics := &LoadMetrics{
        EventsGenerated:   make(map[string]uint64),
        ProcessingLatency: make(map[string]time.Duration),
        ActiveClients:     atomic.LoadInt32(&lg.activeClients),
    }

    for tier, count := range lg.metrics.EventsGenerated {
        metrics.EventsGenerated[tier] = count
    }
    for tier, latency := range lg.metrics.ProcessingLatency {
        metrics.ProcessingLatency[tier] = latency
    }

    metrics.ValidationErrors = lg.metrics.ValidationErrors
    metrics.ComplianceErrors = lg.metrics.ComplianceErrors
    metrics.SecurityViolations = lg.metrics.SecurityViolations

    return metrics
}

// runClient implements a single client's load generation loop
func (lg *LoadGenerator) runClient(ctx context.Context) {
    defer lg.clientWaitGroup.Done()
    defer atomic.AddInt32(&lg.activeClients, -1)

    for {
        select {
        case <-ctx.Done():
            return
        case <-lg.stopChan:
            return
        default:
            // Generate and validate events for each tier
            lg.generateTierEvents(ctx)
        }
    }
}

// generateTierEvents generates events for all tiers with security validation
func (lg *LoadGenerator) generateTierEvents(ctx context.Context) {
    // Generate Bronze event
    start := time.Now()
    bronzeEvent, err := lg.eventGenerator.GenerateEvent("bronze", "security", lg.securityCtx.ToMap())
    if err == nil {
        atomic.AddUint64(&lg.metrics.EventsGenerated["bronze"], 1)
        loadMetrics.eventsGenerated.WithLabelValues("bronze").Inc()
        loadMetrics.eventLatency.WithLabelValues("bronze").Observe(time.Since(start).Seconds())
    }

    // Generate Silver event
    if err == nil {
        start = time.Now()
        silverEvent, err := lg.eventGenerator.GenerateEvent("silver", "security", lg.securityCtx.ToMap())
        if err == nil {
            atomic.AddUint64(&lg.metrics.EventsGenerated["silver"], 1)
            loadMetrics.eventsGenerated.WithLabelValues("silver").Inc()
            loadMetrics.eventLatency.WithLabelValues("silver").Observe(time.Since(start).Seconds())
        }
    }

    // Generate Gold event
    if err == nil {
        start = time.Now()
        goldEvent, err := lg.eventGenerator.GenerateEvent("gold", "security", lg.securityCtx.ToMap())
        if err == nil {
            atomic.AddUint64(&lg.metrics.EventsGenerated["gold"], 1)
            loadMetrics.eventsGenerated.WithLabelValues("gold").Inc()
            loadMetrics.eventLatency.WithLabelValues("gold").Observe(time.Since(start).Seconds())
        }
    }
}

// monitorSecurity performs periodic security validation
func (lg *LoadGenerator) monitorSecurity(ctx context.Context) {
    ticker := time.NewTicker(SecurityValidationInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-lg.stopChan:
            return
        case <-ticker.C:
            lg.validateSecurity()
        }
    }
}

// monitorCompliance performs periodic compliance checks
func (lg *LoadGenerator) monitorCompliance(ctx context.Context) {
    ticker := time.NewTicker(ComplianceCheckInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-lg.stopChan:
            return
        case <-ticker.C:
            lg.validateCompliance()
        }
    }
}

// validateSecurity performs security validation of generated events
func (lg *LoadGenerator) validateSecurity() {
    lg.mutex.Lock()
    defer lg.mutex.Unlock()

    // Security validation implementation
    // This would validate security contexts, encryption, and access controls
}

// validateCompliance performs compliance validation of generated events
func (lg *LoadGenerator) validateCompliance() {
    lg.mutex.Lock()
    defer lg.mutex.Unlock()

    // Compliance validation implementation
    // This would validate against configured compliance rules
}

func init() {
    // Register metrics with Prometheus
    prometheus.MustRegister(
        loadMetrics.eventsGenerated,
        loadMetrics.eventLatency,
        loadMetrics.securityErrors,
        loadMetrics.complianceErrors,
    )
}